### Simple_output 
# Print every line
{ print }
{ print $0 }
# printing certain fields
# the following program to print first and third fields of each input lines.
{ print $1, $3 }
# NF, the number of field
# following program to print the number of fields and the first  and last fields of each input line.
{ print NF, $1, $NF } 
# computing and printing
# following program prints the first filed (name) and total pay ( $2 'rate' times $3 (hours))
{ print $1, $2 * $3 }
# print the line numbers
# use NR and $0 to prefix each line of emp.data with its line number 
{ print NR, $0 }
# Putting text in the output
# print words in the midst of fields and computed values:
{ print "total pay for", $1, "is", $2 * $3 }
### Fancier output
# Lining up fields
printf { format, value1,value2,..,valuen }
{ printf("total pay for %s is $%.2f\n", $1, $2 * $3) }
#The first, %s, says to print the first value, $1, as a string of characters; the
#second, %. 2£, says to print the second value, $2*$3, as a number with 2 digits
#after the decimal point. Everything else in the specification string, including the
#dollar sign, is printed verbatim; the \n at the end of the string stands for a newline,
#which causes subsequent output to begin on the next line.
{ printf("%-8s $%6.2f\n", $1, $2 * $3) }
#The first specification, %-Ss, prints a name as a string of characters leftjustified
#in a field 8 characters wide. The second specification, %6. 2f, prints
#the pay as a number with two digits after the decimal point, in a field 6 characters
#wide:

# sorting output
pipes the output of awk into the sort command 
### Selection
# select by comparison
# lines in which the second field is greater than or equal to 5 
$2 >= 5
# selection by   computation
$2 * $3 > 50 { printf("$%.2f for %s \n", $2 * $3 , $1 ) }
# up program prints the pay of those employees whose total pay exceeds $50
# selection by text content
# this program prints all lines in which the first field is Susie:
$1 == "Susie"
#The operator ==tests for equality. You can also look for text containing any of
#a set of letters, words, and phrases by using patterns called regular expressions.
#This program prints all lines that contain Susie anywhere:
#/Susie/

# combinations of pattern
#Patterns can be combined with parentheses and the logical operators &&,
#and I, which stand for AND, OR, and NOT.

# Data validation
#the following program uses comparison patterns to apply five plausibility tests to each line of emp. data:
NF I= 3 { print $0, "number of fields is not equal to 3" }
$2 < 3.35 { print SO, "rate is below minimum wage" }
$2 > 10 { print $0, "rate exceeds $10 per hour" }
$3 < 0 { print $0, "negative hours worked" }
$3 > 60 { print $0, "too many hours worked" }
#If there are no errors, there's no output.
## BEGIN and END
#The special pattern BEGIN matches before the first line of the first input ·file
#is read, and END matches after the last line of the last file has been processed.
#This program uses BEGIN to print a heading:
BEGIN { print "NAME
{ print }
Notice that print "" prints a blank line, quite different from just
plain print, which prints the current input line.
### Computing with awk
#counting
This program uses a variable emp to count employees who have worked more
than 15 hours:
$3 > 15 { emp=emp+1 }
END     { print emp, "employees worked more than 15 hours" }
For every line in which the third field exceeds 15, the previous value of emp is
incremented by 1. With emp. data as input, this program yields:
3 employees worked more than 15 hours
Awk variables used as numbers begin life with the value 0, so we didn't need to
initialize emp.
## Computing  Sums and Averages
#To count the number of employees, we can use the built-in variable NR,
#which holds the number of lines read so far; its value at the end of all input is
#the total number of lines read.
END { print NR, "employees" }
#The output is:
#6 employees
#Here is a program that uses NR to compute the average pay:
{ pay = pay + $2 * $3 }
END { print NR, "employees"
print "total pay is", pay
print "average pay is", pay/NR
#The first action accumulates the total pay for all employees. The END action
#prints
#6 employees
#total pay is 337.5
#average pay is 56.25
#Clearly, print£ could be used to produce neater output. There's also a potential
#error: in the unlikely case that NR is zero, the program will attempt to
#divide by zero and thus will generate an error message.
## handling text
#Awk variables can hold strings
#of characters as well as numbers. This program finds the employee who is paid
#the most per hour:
$2 > maxrate { maxrate = $2; maxemp = $1 }
END { print "highest hourly rate:", maxrate, "for", maxemp }
#It prints
#highest hourly rate: 5.50 for Mary
#In this program the variable maxrate holds a numeric value, while the variable
#maxemp holds a string. (If there are several employees who all make the same
#maximum pay, this program finds only the first.}
### String Concatenation
#New strings may be created by combining old ones; this operation is called
#concatenation. The program
{ names = names $1 " " }
END { print names }
#collects all the employee names into a single string, by appending each name
#and a blank to the previous value in the variable names. The value of names
#is printed by the END action:
#Beth Dan Kathy Mark Mary Susie
#Variables used to store strings
#begin life holding the null string (that is, the string containing no characters), so
#in this program names did not need to be explicitly initialized.
## print last input lines
#Although NR retains its value in an END action, $0 does not. The program
{ last = $0 }
END { print last }
#is one way to print the last input line:
#Susie 4.25 18
# build in functions
#We have already seen that awk provides built-in variables that maintain frequently
#used quantities like the number of fields and the input line number.
#Similarly, there are built-in functions for computing other useful values.
#Besides arithmetic functions for square roots, logarithms, random numbers, and
#the like, there are also functions that manipulate text. One of these is length,
#which counts the number of characters in a string.
{ print $1, length($1) }

## counting lines, words, and characters
#This program uses length, NF, and NR to count the number of lines, words,
#and characters in the input. For convenience, we'll treat each field as a word.
{ nc = nc + length($0) + 1
nw = nw + NF
}
END { print NR, "lines, .. , nw, 11words,", nc, 11Characters" }
#The file emp. data has
#6 lines, 18 words, 77 characters
#We have added one for the newline character at the end of each input line,
#since $0 doesn't include it.
## 1.6 ontrol-flow  statments
#Awk provides an if-else statement for making decisions and several statements
#for writing loops, all modeled on those found in the C programming
#language. They can only be used in actions.
#if-else statement
#The following program computes the total and average pay of employees making more than $6.00 an hour.
# it use an if to defend against division by zero in computing the average pay.
$2 > 6 { n = n + 1; pay = pay + $2 * $3 } 
END    { if (n>0) 
             print n, "employees, total pay is ", pay,
                     "average pay is ", pay/n
         else
             print "no employees are paid more than $6/hour"
        }
# while statement
# A while statement has a condition and a body. The statements in the body are performed repeatedly while the condition is true.
# 1.7 array
#Awk provides arrays for storing groups of related values.
# reverse - print input in reverse order by lines
{ line[NR] = $0 } # remember each input line
END { i = NR # print lines in reverse order
while (i > 0) {
print line[i]
i = i - 1
}
#1.8 A handful of useful "one-liners"
# Print the total number of input lines
END { print NR }
# Print the tenth input line
NR==10
# Print the last field of every input line
{ print $NF }
# Print the last field of last input line
 { field = $NF }
 END { print field }
# Print every input line which more than four fields
 NF > 4
# Print every input line in which the last field is more than 4
 $NF >4
# Print the total number of fields in all input lines
{ nf=nf +NF }
END { print nf }
# Print the total number of lines that contain Beth
/Beth/ { nlines=nlines +1 }
END { print nlines }
# Print the largest first field and the line that contains it ( assume some $1 is positive )
$1 > max { max =$1; maxline=$0 }
END {print max, maxline }
# Print every line that has at least one field
NF > 0
# Print every line longer than  80 characters
length($0) >80
# Print the nubmer of fields in every line followed by the line itself
{ print NF,$0 }
# Print the first two fields in oppisite order of every line
{ print $2,$1 }
# Exchange the first two fields of every line and then print the line
{ tmep=$1; $1=$2; $2=temp; print }
# Print every line with the first field replaced by the line number
{ $1=NR; print }
# Print every line after erasing the second field
 { $2="";print }
# Print in reverse order fields of  every line
{ for( i =NF; i>0;i=i-1) printf("%s ", $i );
printf("\n")
}
#
# Print the sums of the fields of every line
{ sum=0;
for(i=1;i<=NF;i=i+1) sum=sum+$i;
print sum
}
# Add up all fields in all lines and print the sum
{ for(i=1;i<=NF;i=i+1) sum=sum+$i; }
END { print sum }
# Print every line after replacing each field by its absolute value
{ for (i=1;i<=NF;i=i+1) if($i<0) $i=-$i;
print
}
#Chapter2 The awk language
# The simplest awk program is a sequence of pattern-action statement
# pattern { action }
# pattern { action }
# .......
# 2.1 Patterns
# Summary of Patterns
# 1.Begin { statements }
# The statements are excuted once before any input has been read.
# 2.END { statements }
# The statements are excuted once after all input has been read.
# 3.Expression { statement }
# The statements are excuted at each input line where the expression is true, that is, nonzero or nonnull
# 4. /regular expression/ {statements }
# The statements are excuted at each input line that contains a string matched by the regular expression
# 5.compound pattern { statements }
# A compound pattern  combines expressions with  &&(AND),||(OR),!(NOT), and parentheses; the statements are excuted
# at each input line where the compound pattern is true.
# 6.pattern1,pattern2 { statements }
# A range pattern matches each input line from a line matches by pattern1, to the next line matched by pattern2,
# inclusive;  the statements are excuted at each matching line.
# BENGIN and END do not combnie with other patterns. A range pattern cannot be part of any other pattern
# BEGIN and END are the only patterns that require an action.
# The following program uses the BEGIN action to set the field separator to a tab character(\t) and to put column 
# headings on the output. The second printf statment, which is executed at each input line, formats the output in to 
# a  table, neatly aligned under the column headings. The END section prints the totals.
#  #print countries with column headers and totals
   BEGIN { FS ="\t" # make tab the field separator
           printf("%10s %6s %5s   %s\n\n",
                  "COUNTRY", "AREA", "POP", "CONTINENT")
         }
         { printf("%10s %6d %5d   %s\n", $1, $2, $3, $4)
           area = area + $2
           pop = pop + $3
         }
   END  { printf("\n%10s %6d %5d \n", "TOTAL", area, pop) }
# Expression as Patterns
# Thoughout this book, the term string means a sequence of zero or more characters. These may be stored in variables,
# or apperar literally as string constants like "" or "Asia". The string "", which contains no characters, is called
#  the null string. The term substring means a contiguous sequence of zero or more characters within a string. In 
#  every string, the null string appears as a substring of length zero before the first character, between every
#  parir of adjacent characters, and afer the last character.
#  The operators are listed in following tables
#  Table2-1 Comparison Operators
#  =================================
#  Operator |   Meaning
#  ---------------------------------
#    <      |   less than
#  ---------------------------------
#    <=     |  less than or equal to
#  ---------------------------------
#    ==     | equal to 
#  ---------------------------------
#    !=     | not equal to
#  ---------------------------------
#    >=     | greater than or equal to
#  ---------------------------------
#    >      | greater than
#  ---------------------------------
#    ~      | matched by
#  ---------------------------------
#    !~     | not matched by
#  ---------------------------------
#
#
# String-Matchin Patterns
# Awk provides a notation called regular expressions for specifying and matching strings of characters.
# A string-matching pattern tests whether a string contains a substring matched by a regular expression.
# ======================================================================================================
#                         String-Matching Patterns
#  1. /regexpr/
#    Matches when the current input line contains a substring matched by regexpr.
#  2. expression ~ /regexpr/
#    Matches if the string  value of expression contains a substring matched by regexpr.
#  3. expression !~ /regexpr/
#    Matches if the string value of expression does not contain a substring matched by regexpr.
#  Any expression may be used in place of /regexpr/ in the context of ~ and !~.
#  =======================================================================================================
#  Regular Expressions
#  A regular expression is a notation for specifying and matching strings.
#  =======================================================================================================
#                                 Regular Expressions
#  1. The regular expression metacharacters are:
#    \ ^ $ . [ ] | ( ) * + ?
#  2. A basic regular expression is one of the following:
#    a nonmetacharacter, such as A, that matches itself.
#    an escape sequence that matches a special symbol: \t matches a tab
#    a quoted metacharater, such as \*, that matches the metacharacter literally.
#    ^, which matches the begining of a string.
#    $, which matches the end of a string.
#    ., which matches any single character.
#    a character class:[ABC] matches any of the characters A, B or C.
#    character classes may include abbreviations:[A-Za-z] matches any single letter.
#    a complemented character class:[^0-9] matches any character except a digit.
#
#  3. These operators combine regular expressions into larger ones:
#  alternation: A|B matches A or B
#  concatenation: AB matches A immediately followed by B.
#  closure: A* matches zero or more A's.
#  positive closure: A+ matches one or more A's.
#  zero or one: A? matches the null string or A.
#  parentheses:(r) matches the same string as r does.
#  ================================================================================================
#  Compound Patterns
#  A compound pattern is an expression that combines other patterns, using parentheses and the logical operators
#  ||(OR),&&(AND), and !(NOT). A compound pattern matches the current input line if the expression evaluates to true.
#  The || operator has the lowest precedence, then && ,and finally !. The && and || operator evaluate their operands
#   from left to right; evaluation stops as soon as truth or falsehood is determined.
#
#  Range Patterns
#  A range pattern consists of two patterns separated by a comma, as in  pat1, pat2.
#  A range pattern matches each line between an occurrence of pat1, and the next occurrence of pat2 inclusive;
#  pat2 may match the same line as pat1, making the range a single line.
#  A range pattern cannot be part of any other pattern.
#  2.2 Actions
#  In a pattern-action statment, the pattern determines when the action is to be executed.
#  =========================================================================================
#                                     Actions
#  The statments in actions can include:
#     expressions, with constants, variables, assignments, function calls, etc.
#     print expression-list
#     printf(format,expression-list)
#     if (expression) statement
#     if (expression) statment else statment
#     while (expression) statment
#     for (expression;expression;expression) statment
#     do statment while(expression)
#     break
#     continue
#     next
#     exit expression
#     { statment }
# ============================================================================================
# Expressions
# The primary expressions are the primitive building blocks: they include constants, variables, array references, 
# function invocations, and various built-ins, like field names.
# Our discussion of expressions starts with constants and variables. Then come the operators that can be used to 
# combine expressions. These operators fall into five categories: arithmetic, comparison, logical, conditional, and
# assignment. The built-in arithmetic and string functions come next, followed at the end of the section by the 
# description of arrays.
#    #Constants. There are two types of constants, string and numeric. A string constant is created by enclosing 
#    a sequence of characters in quotation marks, as in "Asia" or "hello, world" or "". Strings constants may contain
#     the escape sequences listed in Table 2-2.
#    A numeric constants can be an integer like 1127, a decimal number like 3.14 or a number in scientific
#    (exponential) notation like 0.707E-1. All numbers are stored in floating point, the precision of which is 
#    machine dependent.
#    #Variables. Expressions can contain several kinds of variables: user-defined,built-in, and fields. The names
#    of user-defined variables are sequences of letters,digits,and underscores that do not begin with a digit; all 
#    built-in variables have upper-case names.
#    A variable has a value that is a string or a number or both. Since the type of a variable is not declared, awk
#    infers the type from context. An uninitialized variable has the string  value "" (the null string) and the 
#    numeric value 0(digit zero).
#    #Built-In Variables. Table 2-5 lists the built-in variables. These variables can be used in all expressions, 
#    and may be reset by the user. FILENAME is set each time a new file is read.
#    #Field Variables. The fields of the current input line are called $1, $2, through $NF; $0 refers to the whole 
#    line.
#                                           
#                                           Table 2-5 Built-in Variables
#    =============================================================================================================
#    Varialbes  |                        Meaning                                               | Default
#    -------------------------------------------------------------------------------------------------------------
#      ARGC     | number of command-line arguments                                             |   -
#      ARGV     | array of command-line arguments                                              |   -
#      FILENAME | name of current input file                                                   |   -
#      FNR      | record number in current file                                                |   -
#      FS       | controls the input field separator                                           |  " "
#      NF       | number of fields in current record                                           |   -
#      NR       | number of records read so far                                                |   -
#      OFMT     | output format for numbers                                                    | "%.6g"
#      OFS      | output field separator                                                       | " "
#      ORS      | output record separator                                                      | "\n"
#      RLENGTH  | length of string matched by match function                                   | -
#      RS       | controls the input record separator                                          | "\n"
#      RSTART   | start of string matched by match function                                    |  -
#      SUBSEP   | subscript separator                                                          | "\034"
#  ================================================================================================================
#  Fields can also be specified by expressions. For example, $(NF +1), has as its initial value the null string. A
#  new field can be created by assigning a value to it. The number of fields can vary from line to line, but there is
#  usually an implementation limit of 100 fields per line.
#  #Arithmetic Operators. Awk provides the usual +, -, *, /, %, and ^ arithmetic operators. The % operator computes 
#  remainders: x%y is the remainder when x is divided by y; its behavior depends on the machine if x or y is
#   negative. The ^ operator is exponentiation: x^y is xY(x's y square). All arithmetic is done in floating point.
#   #Comparison Operators.  Comparison expressions are  those containing either a relational operator or a regular 
#   expression matching operator. The relational operators are <, <=, ==(equals), !=(not equals), >=, and  >. the 
#   regular expression matching operators are ~(is matched by) and !~(is not matched by). The value of a comparison 
#   expression is 1 if it is true and 0 otherwise.
#   #Logical Operators. The logical operators && (AND), ||(OR), and !(NOT) are used to create logical expressions by 
#   combining other expressions. A logical expression has the value 1 if it is true and 0 if false. In the 
#   evaluation of a logical operator, an operand with a nonzero or nonnull value is treated as true; other values 
#   are treated as false. The operands of expressions separated by && or || are evaluated from left to right, and 
#   evaluation ceases as soon as the value of the complete expression can be determined.
#   #Conditional Expressions. A conditional expression has the form   expr1 ? expr2 : expr3.
#   First, expr1 is evaluated. If it is true, that is , nonzero or nonnull, the value of the conditional exprssion
#   is the value of expr2; otherwise, it is the value of expr3. Only one of expr2 and expr3 is evaluated.
#   # Assignment Operators. There are seven assignment operators that can be used in expressions called assignments.
#   The simpleest assignment is an expression of the form: 
#        var = expr
#   where var is a variable or field name, and expr is any expression.
#   The other six assignment operators are +=,-=,*=,/=, and ^=. Their meaning are similar: v op= e has the same 
#   effect as v = v op e, except that v is evaluated only once.
#   #Increment and Decrement Operators. The assignment 
#       n=n+1
#    is usually written ++n or n++ using the unary increment operator ++, which adds 1 to a variable. The prefix form
#    ++n increments n before delivering its value; the postfix form n++ increments n after delivering its value.
#    #Built-In Arithmetic Functions. The built-in arithmetic functions are shown in Table2-6. These functions can be
#    used as primary expressions in all expressions. In the table, x and y are arbitrary expressions.
#
#                            Table2-6 Built-In Arithmetic Functions
#   ============================================================================================================
#   Function  |      Value Returned
#   ------------------------------------------------------------------------------------------------------------
#   atan2(y,x)| arctangent of y/x in the range -pai to pai
#   cos(x)    | cosine of x, with x in radians
#   exp(x)    | exponential function of x, e's x square
#   int(x)    | integer part of x; truncated towards 0 when x>0
#   log(x)    | natural(base e) logarithm of x
#   rand()    | random number r, where 0<=r<1
#   sin(x)    | sine of x, with x in radians
#   sqart(x)  | square root of x
#   srand(x)  | x is new seed for rand()
#   ----------------------------------------------------------------------------------------------------------
#   #String Operators. There is only one string operation, concatenation.It has no explicit operator: string 
#   expressions are created by writing constants,variables, fields, array elements, function values, and other 
#   expressions next to one another. 
#   #String as Regular Expressions. 
#   So far, in all of our examples of matching expressions, the right-hand operand of ~ and !~ has been a regular 
#   expression enclosed in slashes. But, in fact, any expression can be used as the right operand of these operators.
#   Awk evaluates the expression, converts the value to a string if necessary, and interprets the string as a regular
#   expression. For example, the program
#
#     BEGIN { digits = "^[0-9]+$" }
#     $2 ~ digits
#     will print all lines in which the second field is a string of digits.
#   #Built-In String Functions. Awk provides the built-in string functions shown in Table2-7. In this table, r 
#   represents a regular expression(either as a string or enclosed in slashed), s and t are string expressions,
#   and n and p are intergers.
#   The first character in a string is at position 1.
#    
#                 Table2-7 Built-in string functions
#   ===============================================================================================================
#   Function          |                         Description
#   ---------------------------------------------------------------------------------------------------------------
#   gsub(r,s)         | substitute s from r globally in $0, return number of substitutions made
#   gsub(r,s,t)       | substitute s for r globally in string t, return number of substitutions made
#   index(s,t)        | return first position of string t in s, or 0 if t is not present
#   length(s)         | return number of characters in s
#   match(s,r)        | test whether s contains a substring matched by r; return index or 0; sets RSTART and RLENGTH
#   split(s,a)        | split s into array a on FS, return number of fields
#   split(s,a,fs)     | split s into array on field separator fs, return number of fields.
#   sprintf(fmt,expr-list| return expr-list formatted according to format string fmt
#   sub(r,s)          | substitute s for the leftmost longest substring of $0, matched by r; return number of substi-
#                           tutions made
#   sub(r,s,t)        |  substituted s for the leftmost longest substring of t
#   substr(s,p)       | return suffix of s starting at position p
#   substr(s,p,n)     | return substring of s length n starting at position p
#   ----------------------------------------------------------------------------------------------------------------
#   # Number or String? The value of an expression may be automatically converted from a number to a string or vice
#   versa, depending on what operation is applied to it. 
#
#   #Control-Flow Statements
#   Awk provides braces for grouping statements, an if-else statement fro decision-making, and while, for, and do 
#   statements for looping. All of these statements were adopted from C.
#
#   ===============================================================================================================
#                                  Control-Flow Statements
#   { statements }
#       statement grouping
#   if (expression) statement
#       if expression is true, execute statement
#   if (expression) statement1 else statement2
#      if expression is true, execute statment1 otherwise execute statment2
#   while (expression) statement
#      if epxression is ture, execute statement1, then repeat
#   for (expression1; expression2; expression3) statement
#      equivalent to expression1; while (expression2) { statement; expression3 }
#   for(variable in array) statement
#      execute statement with variable set to each subscript in array in turn
#   do statement while (expression)
#      execute statement; if expression is true, repeat
#   break
#      immediately leave innermost enclosing while, for or do 
#   continute
#      start next iteration of innermost enclosing while, for or do
#   next
#      start next iteration of main input loop
#   exit
#   exit expression
#      go immediately to the END action; if within the END action, exit prg
#  The next and exit statements control the outer loop that reads the input lines in an awk program. The next 
#  statement causes awk to fetch the next input line and begin matching patterns starting from the first
#   pattern-action statement. In an END action, the exit statement causes the program to terminate. In any other
#   action, it causes the program to behave as if the end of the input had occured; no more input is read, and the 
#   END actions, if any, are executed.
#     If an exit statement contains an expression
#       exit expr
#    it causes awk to return the value of expr as its exit status unless overridden by a subsequent error or exit.
#    If there is no expr, the exit status is zero. In some operating systems, including Unix, the exit status may 
#    be tested by the program that invoked awk.
#  Empty Statement
#    A semicolon by iteself denotes the empty statement. In the following program, the body of the for loop is an
#   empty statement.
#     BEGIN { FS = "\t" }
#           { for ( i = 1 ; i <= NF && $i != ""; i++)
#                   ;
#             if (i <= NF)
#               print
#           }
#      The program prints all lines that contain an empty field.
#
#  #Arrays
#  Awk provides one-dimensional arrays for storing strings and numbers. Arrays and array elements need not be declar-
#  ed, nor is there any need to specify how many elements an array has. Like variables, array elements spring inot 
#  existence by being mentioned; at birth, they have the numberic value and the string value "".
#  The following program accumulates the populations of Asia and Europe in the array pop. The END action prints the 
#  total populateions of these two continents.
#       /Asia/   { pop["Asia"] += $3 }
#       /Europe/ { pop["Europe"] += $3 }
#       END      { print "Asian population is ",
#                           pop["Asia"], "million."
#                  print "European population is ",
#                    pop["Europe"], "million."
#                }
#   Note that the subscripts are the string constants "Asia" and "Europe". If we had written pop[Asia] instead of 
#   pop["Asia"], the expression would have used the value of the variable Asia as the subscript, and since the varia-
#   ble is uninitialized, the values would have been accumulated in pop[""].
#   Any expression can be used as a subscript in an array reference, so
#     pop[$4] += $3
#  uses the string in the fourth field of the current input line to index the array pop and in that entry accumulates
#  the value of the third field:
#       BEGIN { FS = "\t" }
#             { pop[$4] += $3 }
#       END   { for (name in pop )
#                  print name, pop{name]
#             }
#  The subscripts of the array pop are the continent names; the values are the accumulated populations. This code 
#  works regardless of the number of continents.
#  The last program used a form of the for statement that loops over all subscripts of an array:
#     for(variable in array)
#         statement
#   This loop executes statement with variable set in turn to each different subscript in the array. The order in 
#   which the subscripts are considered is implementation dependent. Results are unpredictable if new elements are 
#   added to the array by statement.
#   You can determine whether a particular sbuscript occurs in an array with the expression 
#       subscript in A
#    This expression has the value 1 if A[subscript] already exists, and 0 otherwise. Thus, to test whether Africa is
#    a subscript of the array pop you can say
#       if("Africa" in pop) ...
#   This condition perforoms the test without the side effect of creating pop["Africa"], which would happen if you 
#   used
#    if (pop["Africa"] != "") ...
#    Note that neither is a test of whether the array pop contains an element with value "Africa".
#
#  # The delete Statement. An array element may be deleted with 
#       delete array[subscript]
#  # The split Function. The function split(str, arr, fs) splits the string value of str into fields and stores them
#  in the array arr. The number of fields produced is returned as the value of split. The string value of the third
#  argument,fs,determines the field separator. If there is no third argument, FS is used.
#  The function 
#     split("7/4/76", arr, "/")
#  splits the string 7/4/76 into three fields using / as the separator; it stores 7 in arr["1"], 4 in arra["2"], and 
#  76 in arr["3"].
#   Strings are versatile array subscripts, but the behavior of numeric subscripts as strings may sometimes appear
#   counterintuitive. Since the string value of 1 and "1" are the same, arr[1] is the same as arr["1]. But notice 
#   that 0 1 is not the same string as 1 and the string 10 comes before the string 2.
#   #Multidimentional Arrays. Awk does not support multidimensional arrays directly but it provides a simulation 
#   using one-dimensional arrays. For example,
#      for (i =1; i <=10; i++)
#         for(j=1;j<=10;j++)
#           arr[i,j] =0
#    creates an array of 100 elements whose subscripts appear to have the form 1,1,1,2 and so on. Internally,
#    however, these subscripts are stored as strings of the form 1 SUBSEP 1, 1 SUBSEP 2, and so on. The built-in
#    variable SUBSEP contains the value of the subscript-component separator; its default value is not a comma
#    but "\034", a value that is unlikely to appear in normal text.
#   The test for array membership with multidimensional subscripts uses a parenthesized list of subscripts, such as 
#     if ((i,j) in arr) ...
#   To loop over such an array, however, you would write 
#      for(k in arr) ...
#   and use split(k,x,SUBSEP) if access to the individual subscript components is needed. 
#   Array elements cannot themselves be arrays.
#
#
#  # 2.3 User-Defined Functions
#   In addition to built-in functions, an awk program can contain user-defined functions. Such a function is defined
#   by a statement of the form
#      function -name- (parameter-list) {
#          statements
#      }
#  A function definition can occur anywhere a pattern-action statement can. Thus, the general form of an awk program
#  is a sequence of pattern-action statements and function definitions separated by newlines or semicolons.
#  The body of a function definition may contain a return statement that returns control and perhaps a value to the 
#  caller. It has the form
#     return expression
#  The expression is optional, and so is the return statement itself, but the returned value is undefined if none is
#  provided or if the last statement executed is not a return.
#  There cannot be any  blanks between the function name and the left parenthesis of the argument list when the 
#  function is called.
#  Within a function definition, the parameters are local variables - they last only as long as the function is 
#  executing, and they are unrelated to variables of the same name elsewhere in the program. But all other variables
#  are global; if a variable is not named in the parameter list, it is visible and accessible throughout the program.
#
#  #2.4 Output
#  The print and printf statements generate output. The print statement is used for simple output; printf is used 
#  when careful formatting is required. Output from print and printf can be directed into files and pipes as well as
#  to the terminal. These statements can be used in any mixture; the output comes out in the order in which it is 
#  generated.
#  ================================================================================================================
#                               Output Statements
#   print
#      print $0 on standard output
#   print expression,expression,...
#      print expression's, separated by OFS, terminated by ORS
#   print expression,expression,... > filename
#      print on file filename instead of standard output
#   print expression,expression,...>>filename
#      append to file filename instead of overwriting previous contents
#   print expression,expression,...| command
#      print to standard input of command
#   printf(format,expression,expression,...)
#   printf(format,expression,expression,...)>filename
#   printf(format,expression,expression,...)>>filename
#   printf(foramt,expression,expression,...)|command
#      printf statements are like print but the first argument specifies output format
#   close(filename),close(command)
#      break connection between print and filename or command
#   system(command)
#      execute command; value is status return of command
#
#  The argument list of a printf statement does not need to be enclosed in parentheses. But if an expression in the
#  argument list of a print or printf statement contains a relational operator, either the expression or the argument
#  list must be enclosed in parentheses. Pipes and system may not be available on non-Unix systems.
#  =================================================================================================================
#  The print Statement
#    The print statement has two forms:
#       print expr1,expr2,..., exprn
#       print(expr1,expr2,..., exprn)
#
#    Both forms print the string value of each expression separated by the output field separator followed by the 
#    output record separator.The statement 
#       print
#     is an abbreviation for 
#       print $0
#    To print a blank line, that is, a line with only a newline, use
#      print ""
#    The second form of the print statement encloses the argument list in parentheses, as in
#       print($1 ":", $2)
#    Both forms of the print statement generate the same output but, as we will see, parentheses are necessary for 
#    arguments containing relational operators.
#    page 56 (68 of 225)
#  #Output Separators
#  The output field separator and output record separator are stored in the built-in variables OFS and ORS. Initially
#  OFS is set to a single blank and ORS to a single newline, but these values can be changed at any time.
#  # The printf Statement
#  The printf statement is used to generate formatted output. It is similar to that in C except that the * format
#  specifier is not supported. Like print, it has both an unparenthesized and parenthesized form:
#       printf format, expr1,expr2,...,exprn
#       printf(format,expr1,expr2,...,exprn)
#  The format argument is always required;it is an expression whose string value conatains both literal text to be 
#  printed and specifications of how the expressions in the argument list are to be formatted, as in Table2-9. Each
#  specification begins with a %, ends with a character that determines the conversion, and may include three 
#  modifiers:
#     -       left-justify expression in its field
#     width   pad field to this width as needed; leading 0 pads with zeros
#     .prec   maximum string width,or digits to right of decimal point
#  Table 2-10 contains some examples of specifications, data, and the corresponding output. Output produced by
#  printf does not contain any newlines you put them in explicitly.
#  # Output into Files
#  The redirection operators > and >> are used to put output into files instead of the standard output.
#
#     TABLE2-9 Printf format-control characters
#  ======================================================================================================
#  character   |    print expression as
# ----------------------------------------------------------------------------------------------------------
#    c         |   ASCII character
# ---------------------------------------------------------------------------------------------
#    d         |   decimal integer
#    e         |    [-]d.ddddddE[+=]dd
#    f         |  [-]ddd.dddddd
#    g         |  e or f conversion, whichever is shorter, with nonsignificant zeros suppressed
#    o         |   unsigned octal number
#    s         | string
#    x         |  unsigned hexadecimal number
#    %         |  print a %; no argument is consumed
# ------------------------------------------------------------------------------------------------------
#
#
#     TABLE2-10  Examples of Printf specifications
# ======================================================================================================
#    fmt     |      $1             |  printf(fmt, $1)
# ------------------------------------------------------------------------------------------------------
#     %c     | 97                  |  a
#     %d     | 97.5                |  97
#     %5d    | 97.5                |     97
#     %e     | 97.5                | 9.750000e+01
#     %f     | 97.5                | 97.500000
#     %7.2f  | 97.5                |   97.50
#     %g     | 97.5                | 97.5
#     %.6g   | 97.5                | 97.5
#     %o     | 97                  | 141
#     %06o   | 97                  | 000141
#     %x     | 97                  | 61
#     |%s|   | January             | |January|
#     |%10s| | January             | |   January|
#     |%-10s|| January             | |January   |
#     |%.3s| | January             | |Jan|
#     |%10.3s| January             | |       Jan|
#   |%-10.3s|| January             | |Jan       |
#   %%       | January             | %
#  -------------------------------------------------------------------------------------------------------------
#
#  #Output Into Pipes
#    It is also possible to direct output into a pipe instead of a file on system that support pipes. The statement
#       print | command
#    cause the output of print to be piped into the command.
#  #Closing Files and Pipes
#   The statement close(expr) closes a file or pipe denoted by expr; the string value of expr must be the same as 
#   the string used to create the file or pipe in the first place. Thus
#      close("sort -t '\t' +1rn")
#    close the sort pip opened above.
#  close is necessary if you intend to write a file , then read it later in the same program. There are also 
#  system-defined limits on the number of files and pipes that can be open at the same time.
# 
# #2.5 Input
#  There are several ways of providing input to an awk program. The most common arrangement is to put input data in 
#  a file, say data, and then type 
#     awk 'program' data
#  Awk reads its standard input if no filenames are given; thus, a second common arrangement is to have another
#  program pip its output into awk.
#  # Input Separators
#    The default value of the built-in variable FS is " ", that is ,a single blank. the field separator can be
#    changed by assigning a string to the built-in variable FS. If the string is longer than one character, it is 
#    taken to be a regular expression. The leftmost nonnull and nonoverlapping substrings matched by that regular
#    expression become the field separators in the current input line.
#  When FS is set to a single character other than blank, that character becomes the field separator. This convention
#  makes it easy to use regular expression metacharacters as field separators:
#      FS = "|"
#  makes | a field separator. But not that something indirect like
#      FS = "[ ]"
#  is required to set the field separator to a single blank.
#  FS can also be set on the command line with the -F argument. The command line 
#      awk -F',[ \t]*|[ \t]+' 'program'
#  sets the field separator to the same strings as the BEGIN action shown above.
#
#  Multiline Records
#  With multiline records, no matter what  value FS has, newline is always one of the field separators.
#  A common way to process multiline records is to use
#     BEGIN { RS = ""; FS = "\n" }
#  to set the record separator to one or more blank lines and the field separator to a newline alone; each line is 
#  thus a separate field. There is a limit on how long a record  can be, usually about 3000 characters.
#  
#
#  page 61 ( 73 of 225 )
